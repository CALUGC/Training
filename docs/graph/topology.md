## 拓撲排序
拓樸排序是對將有向圖轉換成一個線性序列，滿足圖上任意一條邊$(u,v)$，在線性序列中，$u$ 在$v$之前。一個常見的應用學校的擋修機制，要修一門課必須修完他的先修課。

我們藉由擋修機制來轉換圖論，把課程轉為點，把有擋修關係的課程連一條邊，先修課指向後修課。如果把點(修完的課)拔掉，那麼當一個點沒有入度時(意即修完該課程的所有先修課)，就可以被拔掉。

有兩種方法可以找出拓譜排序，一種是用queue，把所有入度$=0$的點都進去，每一次都從queue拿出一個點，將他所有指向的點入度都-1，其中如果有點的入度變成0，一樣將該點放進queue裡面，如果queue裡面沒點，但是還有點入度$>0$，則無解，否則從queue拿出的順序就是拓樸排序。

```cpp
int q[N], din[N];
vector<int> G[N];

bool TopologicalSort(int n){
    int head = -1, tail = -1;
    for(int i = 0; i < n; ++i){
        if(din[i] == 0){
            q[++head] = 1;
        }
    }
    while(head > tail){
        int s = q[++tail];
        for(int i: G[s]){
            if(--din[i] == 0)q[++head] = i;
        }
    }
    return head == n;
}
```

另一種是利用DFS+時間戳記，如果發現有任一條邊$(u,v)$，$tin[u]>tin[v]$，那就無解，否則依照 $tout$ 由大到小形成拓譜排序。

這兩種辦法的時間複雜度皆為 $O(V+E)$。